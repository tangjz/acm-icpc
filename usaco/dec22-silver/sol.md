A

算出每条边需要的量之后得到有向图，拓扑排序

B

如果自己能胜，则尽快胜，否则尽量拖长时间
-> 败者选最小的一步（但不是1），胜者选最大的那一步

SG 值？
-> x = 4k 必败，败者走 step=2 最优；其他都是必胜
-> x = 4k+2 必胜，但胜者只能走 step=2，最终轮数是 2k
-> x = 4k+1/4k+3 必胜，只能走最大的 step=x-4t，然后轮数是 2t+1

能撑过的轮数是 floor(r/2)，取最小最左的

2 2
5 2 2
2 2

C

0 2 2
  0 1
    0

假设已经有 [i+1..n]

如果 r[i][j] == r[i+1][j]，则 a[i] 在 [min(a[i+1..j]), max(a[i+1..j])] 中，否则不在

由此确定最小区间使得 a[i] 在里面，最大区间使得 a[i] 不在里面
-> 如果都存在，则最大区间是最小区间的一个边界，解唯一
-> 如果最小区间不存在，选一个方向然后 check 下，任选一个可行的
